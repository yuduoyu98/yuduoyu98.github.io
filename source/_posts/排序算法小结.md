---
title: 排序算法小结
tags:
  - 知识沉淀
categories:
  - [计算机,算法,排序]
date: 2025-11-07 22:29:57
---

各种排序算法的性能、性质、实现、场景总结
<!-- more -->

### 一、结论

##### 算法性质总结

>**平均**、**最优**、**最差**指的是**时间复杂度**
>**原地**：算法直接在输入数据上操作，只是用常数级别额外空间。递归栈空间可以被宽容接受

这里统计的结果 只针对 ==数组== 排序

| 排序算法 |                平均                |         最优          |                  最差                  |     空间     | 原地  |  稳定性  |
| :--: | :------------------------------: | :-----------------: | :----------------------------------: | :--------: | :-: | :---: |
| 选择排序 |             $O(n^2)$             |      $O(n^2)$       |               $O(n^2)$               |   $O(1)$   |  ✔  |   ❌   |
| 插入排序 |             $O(n^2)$             |       $O(n)$        |               $O(n^2)$               |   $O(1)$   |  ✔  |   ✔   |
| 冒泡排序 |             $O(n^2)$             |       $O(n)$        |               $O(n^2)$               |   $O(1)$   |  ✔  |   ✔   |
| 希尔排序 | $O(n^{1.25})∼O(n^{\frac{3}{2}})$ |       $O(n)$        | $O(nlog^2n)$ \| $O(n^{\frac{3}{2}})$ |   $O(1)$   |  ✔  |   ❌   |
| 堆排序  |            $O(nlogn)$            |     $O(nlogn)$      |              $O(nlogn)$              |   $O(1)$   |  ✔  |   ❌   |
| 归并排序 |            $O(nlogn)$            |     $O(nlogn)$      |              $O(nlogn)$              |   $O(n)$   |  ❌  |   ✔   |
| 快速排序 |            $O(nlogn)$            |     $O(nlogn)$      |               $O(n^2)$               | $O(nlogn)$ |  ✔  |   ❌   |
| 计数排序 |             $O(n+k)$             |      $O(n+k)$       |               $O(n+k)$               | ==$O(k)$== |  ❌  |   ✔   |
| 桶排序  |             $O(n+k)$             |       $O(n)$        |             ==$O(n²)$==              |  $O(n+k)$  |  ❌  | ==✔== |
| 基数排序 |       $O((n+k) \times d)$        | $O((n+k) \times d)$ |         $O((n+k) \times d)$          | $O(n + k)$ |  ❌  |   ✔   |
注释：
- 计数排序 空间复杂度视 是否需要稳定排序而定：非稳定情况 $O(k)$  稳定情况 $O(n+k)$
- 桶排序 最差时间复杂度 取决于桶内排序算法，这里以插入排序为例，当都分到一个桶中时，退化成桶内排序算法
- 桶排序稳定性：前提视桶内排序是稳定的



### 二、细节

#### 简单排序算法（平方级别）

##### 选择排序⭐

**思路**：将数组划分为已排序（左侧）和未排序（右侧）两个连续区域。初始时已排序区域为空。
每一轮从未排序区域中选出最小（或最大）元素，将其与未排序区域的第一个元素交换，从而使已排序区域扩大一个元素。重复此过程，直到未排序区域为空。

**性质**：
- 原地性：✔
- ==稳定性==：❌ （最小元素的选择可以是稳定的，但是首个元素和最小元素的交换会引入不稳定）
- 时间复杂度：
	- 平均：$O(n^2)$ 
	- 最坏：$O(n^2)$ 
	- 最好：$O(n^2)$ 
- 空间复杂度：$O(1)$ 

**手撕**：

``` java
public void sort(int[] nums){
	int n = nums.length;
	for(int i = 0; i < n; i++){
		int idx = i;
		for(int j = i + 1; j < n; j++){
			if(nums[idx] > nums[j]){
				idx = j;
			}
		}
		swap(nums, i, idx);
	}
}
```


##### 插入排序⭐

**思路**：将数组划分为已排序（左侧）和未排序（右侧）两个连续区域。初始时已排序域只有第一个元素。逐个将未排序的第一个元素插入已排序序列中，直到未排序区域为空。

**性质**：
- 原地性：✔
- 稳定性：✔
- 时间复杂度：
	- 平均：$O(n^2)$ 
	- 最坏：$O(n^2)$ 
	- 最好：$O(n)$   (已经有序)  
- 空间复杂度：$O(1)$ 

**手撕**：

``` java
public void sort(int[] nums){
	int n = nums.length;
	for(int i = 1; i < n; i++){
		int num = nums[i];
		int j = i - 1;
		// 找到第一个 <= num 的位置，将num插入
		for(; j >= 0 && nums[j] > num; j--){
			nums[j + 1] = nums[j];
		}
		nums[j + 1] = num;
	}
}
```

##### 冒泡排序⭐

**思路**：每一轮（冒泡）：也就是逐个比对相邻两元素大小，如果逆序进行交换 之后，会将最大（小）冒泡到右侧已排序区域。经过多轮冒泡，已排序区域逐渐扩大，直到全部有序。

**性质**：
- 原地性：✔
- 稳定性：✔
- 时间复杂度：
	- 平均：$O(n^2)$ 
	- 最坏：$O(n^2)$ 
	- 最好：$O(n)$   (已经有序 + 早停机制)  
- 空间复杂度：$O(1)$ 

**手撕**：

``` java
public void sort(int[] nums){
	int n = nums.length;
	boolean alreadySorted = false;
	for(int i = 0; i < n && !alreadySorted; i++){
		// i 表示有几个已经有序了
		alreadySorted = true; // 每一轮冒泡排序前 序列都可能已经有序了
		for(int j = 1; j < n - i; j++){
			if( nums[j] < nums[j - 1]){
				swap(nums, j, j - 1);
				alreadySorted = false;
			}
		}
	}
}
```


#### 高效排序算法（对数级别）

##### 希尔排序⭐

**思想**：插入排序的改进/泛化版本。插入排序的特性是，初始数组越有序，插入排序效率越高。

**思路**：将序列按一定间隔（增量）划分为多个子序列，对每个子序列分别进行插入排序；随后逐步缩小间隔，重复上述过程；当间隔减至 1 并完成最后一轮插入排序时，整个序列即变为有序。

**性质**：
- 原地性：✔
- 稳定性：❌（子序列的插入排序 子序列是稳定的 但子序列间稳定性无法保证）
- 时间复杂度：取决于gap序列的设计
	- 对于 逐个取半的最基本的序列
		- 平均：$O(n^{1.25})∼O(n^{\frac{3}{2}})$
		- 最坏：$O(nlog^2n)$ / $O(n^{\frac{3}{2}})$
		- 最好：$O(n)$  （初始有序，接近$O(n)$）
- 空间复杂度：$O(1)$ 

**手撕**：

``` java
public void sort(int[] nums){
	int n = nums.length;
	for(int gap = n / 2; gap >= 1; gap /= 2){
		for(int i = 0; i < gap; i++){
			// 遍历子序列
			for(int j = i + gap; j < n; j += gap){
				int num = nums[j];
				// 插入排序
				int k = j - gap;
				for(; k >= 0 && nums[k] > num; k -= gap){
					// 找到插入位置 （第一个小于等于num的数）
					nums[k + gap] = nums[k];
				}
				nums[k + gap] = num;
			}
		}
	}
}
```

##### 归并排序⭐⭐⭐

**思路**：以自顶向下递归分治为例。将待排序序列从中间分为两个子序列，递归地对左右子序列分别排序，最后将两个有序子序列合并为一个有序序列

**性质**：
- 原地性：❌ （标准实现不是原地的，但是有原地的变种，且往往被认为是得不偿失的，退化到平方级别或者有极大的常数因子，且代码复杂）
- 稳定性：✔
- 时间复杂度：无论如何都会经过 $logn$ 轮归并
	- 平均：$O(nlogn)$  
	- 最坏：$O(nlogn)$ 
	- 最好：$O(nlogn)$  
- 空间复杂度：$O(n)$  递归栈深度、拷贝数组（非原地）

**适用场景**：
- 链表排序（bottom up的实现方式更适合）
- 外部排序（磁盘随机读写性能差）
- 稳定

**手撕**：

``` java
public void sort(int[] nums){
	int n = nums.length;
	int[] clone = new int[n];
	sort(nums, clone, 0, n);
}

private void sort(int[] nums, int[] clone, int start, int end){
	if(end - start <= 1){
		return;
	}
	int mid = (end - start) / 2 + start;
	sort(nums, clone, start, mid);
	sort(nums, clone, mid, end);
	merge(nums, clone, start, mid, end);
}

// [start, mid) [mid, end)
private void merge(int[] nums, int[] clone, int start, int mid, int end){
	int i = start, j = mid, k = start;
	while(i < mid && j < end){
		if(nums[i] <= nums[j]){
			clone[k++] = nums[i++];
		} else {
			clone[k++] = nums[j++];
		}
	}
	while(i < mid){
		clone[k++] = nums[i++];
	}
	// j < end 的情况下 [j, end) 已经在正确得位置上了
	for(int t = start; t < j; t++){
		nums[t] = clone[t];
	}
}
```


##### 快速排序⭐⭐⭐

**思路**：通过选取一个基准元素，将数组划分为小于和大于基准的两部分，然后递归地对这两部分分别进行分区，直到子区间长度为 0 或 1，此时整个数组有序。

**性质**：
- 原地性：✔  递归栈空间占用忽略 m
- 稳定性：❌  最后会将pivot进行交换 产生不稳定性
- 时间复杂度：
	- 平均：$O(nlogn)$  
	- 最坏：$O(n^2)$       pivot 总是最大/最小值
	- 最好：$O(nlogn)$  必然会有logn层递归 ；最好情况为基准一直选择的是中位数
- 空间复杂度：平均 $O(logn)$  最坏 $O(n)$

**适用场景**：
- 性能要求高、能容忍最坏时间复杂度的退化、允许不稳定、内存、非链表。

**手撕**：

``` java
public void sort(int[] nums) {  
    int n = nums.length;  
    sort(nums, 0, n);  
}  
  
// [start, end)  
private void sort(int[] nums, int start, int end) {  
    if (end - start <= 1) {  
        return;  
    }  
    int idx = partition(nums, start, end);  
    sort(nums, start, idx);  
    sort(nums, idx + 1, end);  
}  
  
// [start, end)  
private int partition(int[] nums, int start, int end) {  
    if (end - start <= 1) {  
        return start;  
    }  
    int pivot = nums[start];  
    // i指向第一个大于pivot的元素位置 j指向第一个待处分区元素位置  
    int i = start + 1, j = start + 1;  
    //  [0, i)   [i, j)  [j, end）  
    // <=pivot   >pivot   未处理  
    for (; j < end; j++) {  
        if (nums[j] <= pivot) {  
            swap(nums, i++, j);  
        }  
    }  
    swap(nums, --i, start);  
    return i;  
}
```

**问题与优化**：
- 最坏情况退化为平方级别：
	- 随机化选择基准的方式，降低最坏情况出现的概率
	- 三数取中法：取首中尾三个数的中位数作为基准
- 大量重复元素时效率低
	- 三路快排
- 小规模数组排序效率不高 (常数开销大)
	- 数组长度小于一定阈值时，改为插入排序
- 缓存局部性差

**其他**：
- Java实现：双轴快排+小数组切换插入排序等等 
	- 具体怎么实现的？为什么这么做？
- 非递归实现？


##### 堆排序⭐⭐

**思路**：
- 原地堆排序：
	- 什么是堆？完整二叉树，对于每个父节点满足，父节点大于或小于任一子节点。
	- 如何原地建堆？ ==如果一个节点的左右子树已经是堆，那么对该节点执行 `sift-down`，就能使以该节点为根的整棵子树成为堆==，利用这个性质，我们可以原地对每个父节点，从下到上，进行`sift-down`，即可确保整体满足堆的性质。
	- 如何原地排序？以升序排序为例，原地建立最大堆后，将堆顶最大元素和队尾交换，缩小堆的大小，并对堆进行`sift-down`, 直到堆为空

**性质**：
- 原地性：✔  ==有原地性的实现方式== 
- 稳定性：❌  
- 时间复杂度：建堆 $O(n)$ \[不是 $O(nlogn)$\] + 排序 $O(nlogn)$   
	- 平均：$O(nlogn)$  
	- 最坏：$O(nlogn)$      
	- 最好：$O(nlogn)$  
- 空间复杂度：$O(1)$

**适用场景**：
- Top K
- 空间复杂度要求极低 $O(1)$

**手撕**：
``` java
public void sort(int[] nums) {  
    int n = nums.length;  
    if (n < 2) return;  
    // 原地建堆（大根堆）  
    for (int i = n / 2 - 1; i >= 0; i--) {  
        siftDown(nums, i, n);  
    }  
    // 原地排序  
    int j = n;  
    while (j > 1) { // 剩一个元素 无需交换  
        swap(nums, 0, --j);  
        siftDown(nums, 0, j);  
    }  
}  
  
// [0,end) 表示堆的范围  
private void siftDown(int[] nums, int p, int end) {  
    int s = p * 2 + 1;  
    while (s < end) {  
        if (s + 1 < end && nums[s + 1] > nums[s]) {  
            s++;  
        }  
        if (nums[p] >= nums[s]) {  
            break;  
        }  
        swap(nums, p, s);  
        p = s;  
        s = 2 * p + 1;  
    }  
}
```



#### 非比较型 排序算法

##### 计数排序

**思路**：
- 确定值域后，空间换时间，将每个值映射到计数数组下标，计数后，按顺序收集。

**性质**：
- 原地性：❌
- 稳定性：✔ （需要额外的$O(n)$空间复杂度进行保障）
- 时间复杂度：$O(n+k)$  k为取值范围
- 空间复杂度：$O(n + k)$ 稳定  $O(k)$ 不稳定

**适用场景**：
- 要求
	- 对排序速度要求极高
	- 整数，或可以转换为整数形式
	- 如果 值域和个数 相近，时间复杂度相当于优化到了线性级别
	- 可支持稳定排序（需要额外空间）
	- 足够空间
- 如：考试成绩、年龄、DNA（映射成数字） 

**手撕**：
- ==如何实现稳定的计数排序？==
```java 
public void sort(int[] nums) {

    // 确定值域：最小值和最大值
    int min = nums[0];
    int max = nums[0];
    for (int num : nums) {
        if (num < min) min = num;
        if (num > max) max = num;
    }

    int range = max - min + 1;
    int[] count = new int[range]; // 计数数组

    // 计数
    for (int num : nums) {
        count[num - min]++;
    }

	// 如果不需要稳定性，直接按顺序"收集"即可.
	// 这里是稳定性版本：
    // 转为前缀和：下标含义由当前数的计数个数 转换为 当前数在排序后数组的下标offset（末尾元素）
    for (int i = 1; i < range; i++) {
        count[i] += count[i - 1];
    }

    // 构建稳定的排序数组：前缀和 配合 从后往前遍历
    // 如：[2_A,  1_B,  2_C,  1_D] 
    // 计数 count[1]=2, count[2]=2 => 前缀和 count[1]=2, count[2]=4
    int[] output = new int[nums.length];
    for (int i = nums.length - 1; i >= 0; i--) {
        int num = nums[i];
        int pos = count[num - min] - 1;
        output[pos] = num;
        count[num - min]--;
    }
}
```

##### 基数排序

**思路**：
- 不通过元素比较，而是通过 按位分桶+顺序收集 来排序
- 将所有数按最大位数补零对齐，从最低位（LSD）开始，逐位按数字0–9分桶并顺序收集，重复至最高位，最终得到有序序列。
	- LSD：从最低位开始；MSD：从最高位开始

**性质**：
- 原地性：❌
- 稳定性：✔
- 时间复杂度：$O((n+k) \times d)$  k为基数（10进制取10）、d为最高位 
- 空间复杂度：$O(n + k)$

**适用场景**：
- 要求
	- 整数，或可以转换为整数形式
	- 数据范围相对集中，且位数不多
	- 稳定排序
	- 足够空间
- 如：对大量手机号、身份证号、学号等定长数字字符串排序

**手撕**：
- 不兼容负数。负数怎么办？分别基数排序 然后拼起来？
```java
public void sort(int[] nums) {  
    int K = 10; // 基数  
    List<Integer>[] buckets = new List[K];  
    for (int i = 0; i < K; i++) {  
        buckets[i] = new ArrayList<>();  
    }  
    int offset = 1;  
    while (offset > 0) { // 防止溢出  
        boolean flag = false; // 是否存在比offset大的元素，判断是否终止  
        // 按位分桶  
        for (int num : nums) {  
            if (num >= offset) flag = true;  
            int digit = (num / offset) % K;  
            buckets[digit].add(num);  
        }  
        // 顺序收集  
        int i = 0;  
        for (int j = 0; j < K; j++) {  
            List<Integer> bucket = buckets[j];  
            for (Integer num : bucket) {  
                nums[i++] = num;  
            }  
            // 清空上一轮的桶  
            bucket.clear();  
        }  
        offset *= K;  
        // 没有更高位，排序结束  
        if (!flag) {  
            break;  
        }  
    }  
}
```



##### 桶排序

**思路**：
- 分治的思想，将数据分到有限数量的桶中，桶内单独排序或递归桶排序，最后顺序合并所有桶
- 桶映射函数

**性质**：
- 原地性：❌（需要额外空间存储桶）
- 稳定性：✔（前提是桶内排序是稳定的，如使用插入排序或归并排序）
- 时间复杂度：
    - 最好/平均：$O(n+k)$ ，其中 k 为桶的数量（当数据均匀分布时，每桶元素极少，桶内排序接近 $O(1)$）
    - 最坏：$O(n^2)$ （所有元素落入同一个桶，且桶内使用 $O(n^2)$ 排序如插入排序）
- 空间复杂度：$O(n+k)$ （n 存储所有元素副本，k 为桶的数量）

**适用场景**：
- 要求
	- 数据近似均匀分布
	- 映射函数设计合理
	- 排序速度要求高，且允许内存开销
- 如：
	- 并行处理（Spark）
	- 天然均匀（hash值）

**手撕**：
- AI生成
```java 
public void sort(int[] nums) {
    if (nums == null || nums.length <= 1) return;

    // 1. 找到最大值和最小值
    int min = nums[0], max = nums[0];
    for (int num : nums) {
        if (num < min) min = num;
        if (num > max) max = num;
    }

    // 2. 特殊情况：所有元素相同
    if (min == max) return;

    // 3. 创建桶：桶数通常取 n（元素个数）
    int n = nums.length;
    List<List<Integer>> buckets = new ArrayList<>(n);
    for (int i = 0; i < n; i++) {
        buckets.add(new ArrayList<>());
    }

    // 4. 将元素分配到桶中
    // 映射公式：bucketIndex = (num - min) * (n - 1) / (max - min)
    // 保证最大值落入最后一个桶（index = n-1）
    for (int num : nums) {
        int bucketIndex = (int) ((long)(num - min) * (n - 1) / (max - min));
        buckets.get(bucketIndex).add(num);
    }

    // 5. 对每个桶排序（使用 Collections.sort，底层是 Timsort，稳定）
    int idx = 0;
    for (List<Integer> bucket : buckets) {
        if (!bucket.isEmpty()) {
            Collections.sort(bucket); // 稳定排序
            for (int val : bucket) {
                nums[idx++] = val;
            }
        }
    }
}
```

### 三、对比

#### 堆排序 vs 快排 vs 归并

决策树：

```
是否需要稳定排序？
├── 是 → 归并排序
└── 否
    └── 数据结构是否为链表？
        ├── 是 → 归并排序（bottom-up，适合链表）
        └── 否
            └── 是否为外部排序（数据在磁盘/超大）？
                ├── 是 → 外部归并排序
                └── 否（即：内存中的数组）
                    └── 是否内存极度受限（要求 O(1) 额外空间）？
                        ├── 是 → 堆排序
                        └── 否
                            └── 是否能容忍最坏 O(n²) 时间？
                                ├── 否 → 堆排序 或 归并排序
                                └── 是
                                    └── 数据特征？
                                        ├── 大量重复元素 → 三路快排（3-way QuickSort）
			                            └── ...
```

- 为什么链表只适合归并？
	- 快排和堆排序严重依赖随机访问（堆找父节点，快排定位pivot并分区）
- 为什么外部排序只适合归并？
	- 归并顺序读写，IO友好；快排和堆排序随机读写多，磁盘寻道开销大
- 具体什么情况下空间极度受限？
	- 嵌入式系统（如单片机、传感器），操作系统内核
- 具体什么情况下需要稳定？
	- 一般前端的表格，对于已有的排序，根据别的维度重新排序时，稳定性会提高用户体验
	- ... ...
- 具体什么情况下不能容忍 O(n²)？
	- 实时系统、关键服务、SLA严格性能要求